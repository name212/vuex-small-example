<html>
    <head>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script> 
        <script src="https://unpkg.com/vuex"></script>
    </head>
    <body>
        <div id = "app">
            <!--Прям простенько про vue и vuex в одном месте-->
            <!--Первое простой коунтер, его храним с помощью vuex как бы в глобальном состоянии-->
            <!--Т.е если нужно коунтер показывать в нескольких компонентах, то используем vuex-->
            Counter is {{count}} negative count is {{negativeCount}}
            <br>
            <!--С помощью кнопки може инкрементировать значение-->
            <button v-on:click="updateCounter"> Increment </button>

            <br><br>
            <!--Пару храним в самом компоненте. Они никому больше доступны не будут-->
            Pair is ({{pair.first}}, {{pair.second}})
            <!--При нажатии на кнопку пару будем рандомизировать-->
            <button v-on:click="updatePair"> Rnd pair </button>
        </div>
        <script type="application/javascript">
                // тут это не нужно в принципе
                Vue.use(Vuex);

                // создаем тот самый стор
                const store = new Vuex.Store({
                    state: {
                        // храним абстрактный счетчик
                        // все поля должны проинициализировать, иначе реактивная магия не сработает
                        count: 0
                    }, 
                    
                    // геттеры используется для получения "вычисленного" состояния
                    // т.е. берем из стора состояние и как-то преобразуем без изменения самого состояния
                    getters: {
                        // в этом простом пример будем получать отрицательное значение счетчика
                        negativeCount : state => -state.count,
                    },
                    
                    // мутации - то что изменяет состояние
                    // должны быть всегда синхронными
                    // запросов тут быть не должно
                    mutations: {
                        // задаем мутацию "инкремент"
                        // первое значение всегда стейт (его поля всегда меняем)
                        // второе дополнительный пайлоад
                        // в нашем случае пайлоадом выступает значение на которое нужно инкрементить
                        // пайлоад можно не передавать, в этом случае будем инкрементить на 1
                        increment (state, on_value) {
                            on_value = on_value || 1
                            state.count += on_value
                            console.log("Counter incremented")
                        }
                    },
                    
                    // действия - выполняют какую-то работу и инициируют мутации
                    // в основном "работа" будет связана с сетью 
                    // ибо в действиях можно выполнять асинхронные операции
                    // т.е цепь следующая
                    //  компонент вызывает действие => действие идет в сеть, получет данные => действие вызавает мутацию
                    // ctx - это vuex объект, payload какя-то наша хрень, её может и не быть
                    actions: {
                        // в нашем случае симулируем какое-то изменения счетчика на 1
                        // например, клик по ссылке
                        affectCount : function(ctx, payload){
                            // тут если есть пайлоад, то логируем из него сообщение
                            // типа отслеживаем откуда пришел экшон 
                            if(payload){
                                console.log("Get count payload msg is " + payload.msg)
                            }
                            console.log("Wait network request...")
                            // симулируем работу с сетью через таймаут
                            setTimeout(() => {
                                // считаем что отправили успешно и увеличиваем счетчик на 1
                                // (мутируем стейт)
                                ctx.commit('increment')
                            }, 2000);
                        }
                    }
                });

                var app = new Vue({
                    // на какой элемент цеплаем vue
                    // если не передать, то mounted событие не будет
                    el: '#app',
                    // прокидываем наш стор, теперь он доступен по this.$store
                    store,
                    // данные компонента
                    // используем в шаблоне
                    data: {
                        // умолчания для пары
                        pair : {
                            first : 1,
                            second: 2
                        }
                    },
                    
                    // вычислимые свойства - те которые вычисляются с помощью функции
                    // в нашем случае вычислимые свойства мы берем из глобального состояния
                    // тоже юзаем в шаблоне
                    computed :{
                        // текущее значение счетчика
                        // место длинной записи можно использовать
                        // ...Vuex.mapStates(['count'])
                        count: function(){
                            return this.$store.state.count;
                        },
                        // негативное значение получаем с помощью геттера
                        // длинная запись будет такая
                        // negativeCount : function(){
                        //      return this.$store.getters.negativeCount;
                        // }
                        ...Vuex.mapGetters(['negativeCount']) 
                    },
                
                // вызывается, когда vue повешен на элемент
                mounted(){
                    // действия в стере вызываются с помощью dispatch
                    this.$store.dispatch('affectCount', {msg : 'from MOUNTED hook'})
                    // здесь симулируем обращение к сети после загрузки компонента
                    setTimeout(() => {
                        console.log("Direct commit increment on 2 after timeout")
                        // также мутацию можно вызвать напрямую через commit
                        // но лучше использовать действия из компонента для единобразия
                        // тут просто хотел показать, что так можно
                        this.$store.commit('increment', 2)
                        
                        // также после этого обнулим пару компонента
                        // здесь положим такой смысл - мы сзодили куда-то в сеть и сеть ответила, 
                        // что пару нужно обнулить
                        // выносить это в vuex и дергать экшоны не имеет смысла,
                        // ибо наша пара только в нашем компонете и используется
                        console.log("Reset pair after mounted")
                        this.pair.first = 0;
                        this.pair.second = 0;
                    }, 1000)
                },

                // методы используем для обработчиков событий
                methods:{
                    // инкремент через кнопку
                    updateCounter: function(e){
                        this.$store.dispatch('affectCount', {msg : 'from BUTTON'})
                    },
                    
                    // рандомизируем пару в компоненте
                    updatePair: function(e){
                        this.pair.first = Math.floor(Math.random() * 5);
                        this.pair.second = Math.floor(Math.random() * 3);
                        console.log("Pair randomized")
                    }
                }
            });
        </script>
    </body>
</html>
